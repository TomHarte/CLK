//
// CMOSRAM.hpp
// Clock Signal
//
// Created by Thomas Harte on 20/03/2024.
// Copyright Â© 2024 Thomas Harte. All rights reserved.
//

#pragma once

#include "Components/I2C/I2C.hpp"
#include "Outputs/Log.hpp"

#include <array>
#include <optional>

namespace Archimedes {

struct CMOSRAM: public I2C::Peripheral {
	CMOSRAM() {
		ram_ = default_ram;
	}

	void start(bool is_read) override {
		expecting_address_ = !is_read;
	}

	// TODO: first 16 addresses are registers, not RAM.

	std::optional<uint8_t> read() override {
		if(address_ < 16) {
			Logger::error().append("TODO: read at %d", address_);
		}

		const uint8_t result = ram_[address_];
		++address_;
		return result;
	}

	bool write(uint8_t value) override {
		if(expecting_address_) {
			address_ = value;
			expecting_address_ = false;
			return true;
		}

		if(address_ < 16) {
			Logger::error().append("TODO: write at %d", address_);
			return true;
		}

		ram_[address_] = value;
		++address_;
		return true;
	}

private:
	bool expecting_address_ = false;
	uint8_t address_;

	std::array<uint8_t, 256> ram_{};

	// This is the default contents of RAM as written by RISC OS 3.11.
	static constexpr std::array<uint8_t, 256> default_ram = {
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x03, 0x14, 0x00, 0x6f, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6d,
		0x00, 0xfe, 0x00, 0xeb, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x10, 0x50, 0x20, 0x08, 0x0a, 0x2c,
		0x80, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x5c, 0x13, 0x00, 0x00, 0x04, 0xfd, 0x08, 0x01, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	};

	using Logger = Log::Logger<Log::Source::CMOSRTC>;
};

}
